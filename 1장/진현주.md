# 01. 리액트 개발을 위해 꼭 알아야 할 자바스크립트

# 📍 자바스크립트의 동등 비교

왜 중요할까?  
리액트 컴포넌트의 렌더링 판단(props), hook의 의존성 배열 작동 방식, 메모이제이션 등 => 모두 `동등 비교`를 통해 이루어진다

## 데이터 타입

원시 타입: boolean, null, undefined, number, string, symbol, bigint  
객체 타입: object

### undefined

'선언 이후'에 값 할당되지 않았을 때, 자동으로 할당되는 값

### null

'명시적'으로 비어 있음을 나타내는 값

```javascript
// 주의: 타입은 null 이 아니다 
typeof null === 'object' // true
```

### Boolean

true or false 만 가질 수 있는 타입  
truthy, falsy 한 값도 존재 (조건문에서 사용될 때)

- truthy: `{}`, `[]`, `1`
- falsy: `-0`, `NaN`, `""`, `null`, `undefined`

### Number

모든 숫자(정수, 실수..)를 '하나의' 타입으로 저장

### BigInt

number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위함(ES2020)  
number 와는 타입이 달라서 `===` 연산 시 false 반환

```javascript
// 사용법
const bigInt1 = 9007199254740991n; // 끝에 n
const bigInt2 = BigInt(9007199254740991); // BinInt 함수
```

### String

텍스트 타입의 데이터 저장하기 위한 타입   
차이점) 작은/큰 따옴표 <-> 백틱

- 템플릿 리터럴
    - 백틱(`)을 사용한 문자열
    - 줄바꿈 가능
    - 내부에 표현식 사용

```javascript
const backtickStr = `
안녕하세요
` // 공백 포함

// "" 따옴표로 할당시 에러 반환
```

### Symbol

중복되지 않는 고유한 값 나타내기 위함

```javascript
// Symbol 함수로 생성
const a = Symbol('a')
const a2 = Symbol('a')
console.log(a === a2) // false

// 동일 값 사용시
const b = Symbol.for('b')
const b2 = Symbol.for('b')
console.log(key === key2) // true
```

### 객체

배열, 함수, 정규식, 클래스 등 포함  
'참조'를 전달한다고 해서 참조 타입(reference type)  
참조는 메모리 주소를 의미한다

내부 속성은 자유롭게 변경 가능하다.  
다만, `Object.freeze()` 와 같은 method 사용시 -> 변경 불가 처리 가능

```javascript
const fitst = function(){}
const second = function(){}

first === second; // false
```

## 값을 저장하는 방식의 차이

### 원시 타입

'값'이 저장된다  
단순 값을 비교하기 때문에, 각각 선언해도 값이 같으면 동일한 결과가 나온다

```javascript
const a = 'hi'
const b = 'hi'

console.log(a === b) // true
```

### 참조 타입

'참조'를 전달한다  
실제 값이 아닌, 메모리 주소를 저장하기 때문에 => 주소를 통해 객체에 접근 가능!

```javascript
const a = { age: 20 }
const b = { age: 20 }

console.log(a === b) // false
console.log(a.age === b.age) // true // 내부 속성값은 원시타입이기 때문에 값으로 비교
```

## Object.is

`==`, `===` 와 같이 동등 비교를 하기 위한 또 다른 방법

- 같은 타입이 아닐시 강제 형변환하여 비교하는 `==`와 달리, 타입이 다르면 아예 false (`===` 연산자와 동일)
- `===` 와는 0과 NaN 에 대해 차이점 존재 (`===` 가 체크하지 못하는 케이스 보완)
    - 이 외에는 동일 작동

```javascript
-0 === +0 // true
Object.is(-0, +0) // false

Number.NaN === NaN // false
Object.is(Number.NaN, NaN) // true

NaN === 0/0 // false
Object.is(NaN, 0/0) // true
```

## 리액트에서의 동등 비교

리액트에서 렌더링 여부 판단, hook의 의존성 배열 등 동등 여부를 판단할 때 -> `Object.is` 사용  
다만, 구형 브라우저를 대비하여 폴리필 넣어줌

리액트는 주로 props를 비교하기 위함이기에 1 depth의 비교에만 적용된다  
즉, 중첩 객체를 props로 넘겨줄 때에는 주의해야 한다

```typescript
// 책에 안나온 또 다른 부분 🧐
function areHookInputsEqual(
  nextDeps: Array<mixed>,
  prevDeps: Array<mixed> | null,
): boolean {

// ...

  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }
  return true;
}
```

```typescript
// react/packages/shared/objectIs.js

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x: any, y: any) {
  return (
    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
  );
}

const objectIs: (x: any, y: any) => boolean =
  typeof Object.is === 'function' ? Object.is : is;

export default objectIs;
```

# 📍 함수

## 함수란 무엇인가?

작업을 수행하거나 값을 계산하는 등의 과정을 표현하고  
이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것

```javascript
function sum(a, b) { // 매개변수
  return a + b
}

sum(3, 5) // 인수

function Component(props) { // 대문자로 시작
  return <div>{props.count}</div>
} // Component 호출시, props는 단일 혹은 전개 연산자로 넘길 수 있다
```

## 함수 정의하는 4가지 방법

### 함수 선언문

어떠한 값으로도 표현되지 않기 때문에, 표현식이 아닌 '문'

```javascript
function add(a, b) {
    return a + b
}
```

### 함수 표현식

함수를 변수에 할당하는 것  
how? => 일급 객체: 다른 객체에 적용 가능한 연산을 모두 지원하는 객체 (할당, 매개변수, 반환값...)

```javascript
const sum = function (a, b) {
    return a + b
}
```

- **호이스팅**
    - 함수 선언문이 마치 코드 최상단으로 끌여 올려진 것처럼 작동하는 자바스크립트의 특징
    - 함수 선언문) 함수를 선언했기에, 함수 호이스팅에 의해 함수를 메모리에 등록함으로써 코드 순서에 상관없이 호출 가능
    - 함수 표현식) 변수에 할당하기에 변수 호이스팅이 이루어지며, 할당이 이루어지기 전까지 실행하면 에러 발생

### Function 생성자

pass !

### 화살표 함수

화살표를 활용해서 함수 생성  
constructor 사용 불가, arguments 존재하지 않음

```javascript
const add = (a, b) => {
  return a + b
}
```

- **this 바인딩** 차이
    - this: 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값
    - 일반 함수) 전역 객체
    - 화살표 함수) 함수 내부에서 this 참조시, 상위 스코프의 this 가리킴
        - 실 사용..) 화살표 함수가 훨씬 편하다 ^.^ bind를 일일이 해줘야 되기 때문에 화살표 함수로 사용한다


## 다양한 함수 살펴보기

### 즉시 실행 함수

IIFE (Immediately Invoked Function Expression)  
함수를 정의한 그 순간, 즉시 실행되는 함수 (재사용 불가. 일회성 사용)  
일반적으로 함수에 이름을 붙이지 않는다 (어차피 재호출 불가능하기에)

단 한번만 실행되고 끝나야되는 경우에는 사용 가능

### 고차 함수

함수를 '인수'로 받거나: `map`, `filter`...  
새로운 함수를 '결과'로 반환하는 함수

## 함수를 만들 때 주의해야 할 사항

- 사이드 이펙트 억제: 함수 외부에 영향을 끼치지 않는 순수 함수 (동일한 input, 동일한 output)
    - 리액트 공식문서) [컴포넌트 순수하게 유지하기](https://ko.react.dev/learn/keeping-components-pure)
- 가능한 함수를 작게 만들기: "함수는 하나의 일을, 그 하나만 잘하면 된다"
    - 길면, 코드 내부에서 어떤 일이 일어나는지 추적하기 어려워짐
- 누구나 이해 가능한 함수명

# 📍 클래스

> 회사에서 마주하지 않을 것 같지만, 마주할 수 있다 🥹

## 클래스란 무엇인가?

특정한 객체를 만들기 위한 일종의 템플릿 개념  
리액트 16.8 버전 이전에는 클래스형 컴포넌트 사용

```javascript
class Car {
  // constructor: 생성자 (객체 생성 method. 생략 가능)
  constructor(props) {
    this.name = name // 프로퍼티: 내부에 정의할 수 있는 속성값 (public 이 default) 
  }

  // 인스턴스 메서드 (=프로토타입 메서드)
  hi() {
      console.log(this.name)
  }
  
  // 정적 메서드: 인스턴스가 아닌 클래스의 이름으로 호출 가능 // Car.hello()
  static hello() {
    console.log('나는 자동차')
  }
  
  // setter (값 할당할 때)
  set age(value) {
      this.carAge = value
  }
  
  // getter (값 가져올 때)
  get age() {
      return this.carAge
  }

}

const myCar = new Car('자동차');

myCar.age = 20
console.log(myCar.age) // 20

Object.getPrototypeOf(myCar) // constructor + hi(인스턴스 메서드) Method 반환
Object.getPrototypeOf(myCar) === Car.prototype // true (Car의 프로토타입 받음)
```

- 프로토타입 체이닝
    - 프로토타입에 있는 메서드를 찾아서 실행을 도와주는 것
    - 직접 객체에 선언하지 않았어도, 자기 자신부터 시작해서 상위로 올라가며 최상위 객체인 Object까지 확인한다
    - ex: hi => myCar에서 시작해 Car에서 확인 가능
    - ex: toString: 최상위인 Object에서 확인 가능

- 상속
    - 자식 클래스에서 기존 클래스를 이어 받음
    - `extends React.Component` => React의 클래스형 컴포넌트에서도 사용

# 📍 클로저

React의 함수형 컴포넌트에서는 `클로저` 개념이 중요하다  
hook 원리, 함수 컴포넌트 구조와 작동 방식 등이 클로저에 의존하고 있다

## 클로저의 정의

> 클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합 - MDN

- 어휘적 환경이란?

`변수`가 코드 내부 어디에서 선언됐는 지를 말하는 것  
호출되는 방식에 따른 `this` <-> 코드가 작성되는 순간 정적으로 결정되는 `Closure`  
=> 어휘적 환경을 조합해 코딩하는 기법

```javascript
function add() {
    const a = 10;
    
    function innerAdd() {
        const b = 20;
        console.log(a + b); // a의 유효범위: add, b의 유효범위: innerAdd
    }
    
    innerAdd(); // 30
}

add();
```

## 변수의 유효 범위, 스코프

변수의 유효 범위 = 스코프

- 전역 스코프 (global scope)
    - 전역 레벨에 선언하는 것
    - 어디서든 변수 호출 가능
    - 브라우저 환경에서의 전역 객체: `window`
    - Node.js 환경에서의 전역 객체: `global`

```javascript
var global = 'global'

function getGlobal() {
  console.log(global) // global
}
console.log(global === window.global) // true
```

- 함수 스코프 (function scope)
    - 자바스크립트는 기본적으로 함수 레벨 스코프

```javascript
function temp() {
    if (true) {
        var global = 'global';
        console.log(global) // global
    }
    console.log(global); // global
  
    // global 은 {} 블록문 안에서 선언됐지만, 밖에서도 접근 가능
}
```

++ 중첩으로 된 함수 안에서도 최상위의 변수는 값을 이어받아 접근 가능하다!


## 클로저의 활용

전역 스코프 => 누구든 접근 가능하다는 위험성이 있다

```javascript
function Counter() {
    var counter = 0;
    
    return {
        increase: function () {
            return counter++;
        }
        // ...
    }
}

var c = Counter();
console.log(c.increase()) // 1
console.log(c.increase()) // 2
```

리액트에서의 클로저

- setState 호출시, `prev` 값을 가져오는 것은 클로저를 활용했기 때문이다
- 내부의 최신값(prev)을 계속 알고 있다
- 외부 함수인 `useState`가 끝났어도, 내부 함수인 `setState`는 자신이 선언된 외부 함수가 선언된 환경을 기억하기에 => 계속 state 사용 가능

```javascript
function Component() {
    const [state, setState] = useState();
    
    function handleClick() {
        setState((prev) => prev + 1);
    }
}
```

## 주의할 점

### 예상과는 다른 결과가 나올 수 있다

```javascript
for (var i=0; i<5; i++) {
    setTimeout(function () {
      console.log(i);
    }, i * 1000)
}
```

결과) 0, 1, 2, 3, 4, 5초 뒤에 5만 출력된다

`i`는 전역 변수.  
우선적으로 바깥의 for문 순회에 따라 5로 업데이트가 되어  
테스크 큐에 있는 `setTimeout` 실행시, 이미 5가 된 `i`가 반환된다

- 정확한 결과를 반환하려면,
    - `i`를 블록 레벨 스코프인 `let`으로 변경한다
        - 각 for문이 개별적으로 각각의 스코프를 지니기에 => `setTimeout` 실행시 개별 `i`를 바라보게 된다
    - `setTimeout` 내부에 즉시 실행 익명 함수를 선언한다
        - 즉시 실행 임명 함수는 각 for 문마다 생성되고 실행되기를 반복
        - = 각각의 고유한 스코프를 지니게 된다


### 클로저는 공짜가 아니다!

- 사용시 비용이 든다
- 클로저가 생성될 때마다, 선언적 환경을 기억해야 하기 때문이다
- `Array.from({ lenght: 100000 })` 과 같이 배열이 긴 작업을 할 때 그 차이는 더 느껴진다
- 메모리 용량을 많이 잡아먹기에 성능에 영향을 줄 수 있다
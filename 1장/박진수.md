# [1장] 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등 비교
### 자바스크립트의 데이터 타입
원시 타입
- undefined
  - 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값이다.
  ```tsx
  let foo;

  typeof foo === 'undefined' // true

  function bar(hello) {
    return hello;
  }

  typeof bar() === 'undefined'; // true
  ```
  - null과 undefined 원시 타입은 각각 null과 undefined만 가질 수 있으며, 그 밖의 타입은 가질 수 있는 값이 두개 이상(boolean의 true, false와 같이) 존재한다.
 
- null
  - 아직 없거나 비어있는 값을 표현할 때 사용한다.
  ```tsx
  typeof null === 'object' // true
  ```
  - 그런데 문제는 null 타입이 'object' 결과를 도출하고 이는 JS의 초창기 문제다.
  - 그래서 옵셔널 체이닝을 활용해서 undefined로 분기처리 하는 것이 TypeError를 방지할 수 있는 방법이라고 생각한다.
 
- Boolean
  - true와 false만을 가질 수 있는 데이터 타입이다. 주로 조건문에 많이 쓰인다.
  - 다만 조건문에서 boolean 형 이외에도 마치 true와 false로 취급되는 truthy와 falsy가 있다는 걸 기억해야 한다.
  - falsy
  ```md
  - false: 대표적인 falsy 값
  - 0, -0, 0n, 0x0n: falsy
  - NaN: falsy
  - undefiend: falsy
  ```
  - truthy
  ```md
  - 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다.
  - 즉, {}, [] 모두 truthy한 값이다.
  - 특히 개발할 때 분기처리를 단순히 진행한다면 truthy의 이러한 속성 때문에 배열에 값이 없어도 통과되므로 주의해야한다.
  
  ```tsx
  const useCafeStudyFilterStore = create<CafeStudyType>((set) => ({
  categories: [],
  dates: [],
  cafes: [],
  toggleCategory: (category) =>
    set((state) => ({
      categories: state.categories.includes(category)
        ? state.categories.filter((c) => c !== category)
        : [...state.categories, category],
    })),
  toggleDate: (date) =>
    set((state) => ({
      dates: state.dates.includes(date)
        ? state.dates.filter((d) => d !== date)
        : [...state.dates, date],
    })),
  toggleCafe: (cafe) =>
    set((state) => ({
      cafes: state.cafes.includes(cafe)
        ? state.cafes.filter((c) => c !== cafe)
        : [...state.cafes, cafe],
    })),
  }));

  const { categories, dates, cafes, toggleCategory, toggleDate, toggleCafe } = useCafeStudyFilterStore();

  {categories || dates || cafes ? (
    <Style.FilterBar>|</Style.FilterBar>
  ) : null} // 여기서 categories, dates, cafes 데이터가 없어도 truthy로 판단되어서 '|'가 렌더링 되는 문제.
  ```
  
- Number
  - Number는 -(2^53 - 1)과 2^53 - 1 사이의 값을 저장할 수 있다.
  - 그 이외의 값은 BigInt가 처리할 수 있다.
  ```tsx
  const a = 1;

  const maxInteger = Math.pow(2, 53);
  maxInteger - 1 === Number.MAX_SAFE_INTEGER // true

  const minInteger = -(Math.pow(2, 53) - 1)
  minInteger === Number.MIN_SAFE_INTEGER // true
  ```
  - 또한 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않아서 각 진수별로 값을 표현해도 모두 10진수로 해석된다.
 
- BigInt
  - ES2020에서 새롭게 나온 것으로, 앞서 말한 Number가 커버하지 못하는 범위까지 다룰 수 있다.
 
- String
  - 자바스크립트 문자열의 특징 중 하나는 문자열이 원시 타입이며 변경 불가능하다는 것이다.
  - 한번 문자열이 생성되면 그 문자열을 변경할 수 없다.
  ```tsx
  const foo = 'bar';

  console.log(foo[0]); // 'b'

  foo[0] = 'a';

  console.log(foo); // bar -> 반영 안됨.
  ```

- Symbol
  - ES6에서 새롭게 추가된 7번째 타입으로, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌다.
  - 심벌은 오직 Symbol() 함수를 사용해서만 만들 수 있다.
  ```tsx
  const key = Symbol('key');
  const key2 = Symbol('key');

  key === key2; // false

  // 동일한 값을 사용하기 위해서는 Symbol.for를 활용한다.
  Symbol.for('hello') === Symbol.for('hello'); // true
  ```

객체 타입
- 원시 타입을 제외한, 자바스크립트를 이루고 있는 대부분의 타입이 객체 타입이다.
- 여기에는 배열, 함수, 정규식, 클래스 등이 포함된다.
- 객체 타입은 참조를 전달한다고 해서 참조 타입으로도 불린다는 점을 기억해야 한다.
```tsx
const hello1 = function () {};
const hello2 = function () {};

hello1 === hello2; // false
// 함수의 내용이 같아 보여도 참조가 다르기 때문에 false가 반환된다.
```

### 값을 저장하는 방식의 차이
원시 타입과 객체 타입의 가장 큰 차이점은, 값을 저장하는 방식의 차이다.
- 원시 타입
  - 값을 스택 메모리에 저장하고 비교는 값 자체를 비교한다.
  ```tsx
  let a = 10;  // 숫자 10이 스택 메모리에 저장됨
  let b = 'hello'; // 문자열 'hello'가 스택 메모리에 저장됨
  console.log(a===b); // true
  ```
- 객체 타입
  - 값을 힙 메모리에 저장하고 비교는 메모리 참조 값을 비교한다.
  ```tsx
  let obj1 = { key: 'value' };
  let obj2 = { key: 'value' };
  let obj3 = obj1;

  console.log(obj1 === obj2); // false, 같은 내용이지만 다른 메모리 주소
  console.log(obj1 === obj3); // true, 같은 메모리 주소를 참조
  console.log(obj1.key === obj2.key); // true, 원시값인 내부 속성값을 비교하면 동일하다
  ```

### 자바스크립트의 또 다른 비교 공식, Object.is
- Object.is는 ==와도 다르고 ===와도 다르다.
- Object.is는 강제 형변환을 진행하는 ==와는 다르게 그대로 값을 비교하기 때문에 ===와 같다고 생각할 수 있지만, Object.is가 좀 더 개발자가 예상하는 방식으로 동작한다.
```tsx
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0 // false
Object.is(NaN, 0 / 0) // true
```
- 다만, 객체 비교에 있어서는 앞서 이야기한 방법과 동일하다.

### 리액트에서의 동등 비교
- 리액트에서는 비교를 Object.is로 먼저 수행하고 객체처럼 Object.is로 비교를 수행하지 못하는 경우 얕은 비교를 한 번 더 수행한다.
```tsx
import { memo, useEffect, useState } from 'react'

type Props = {
  counter: number;
}

const Component = memo((props: Props) => {
  useEffect(() => {
    console.log('Component has been rendered!');
  })

  return <h1>{props.counter}</h1>
})

type DeeperProps = {
  counter: {
    counter: number
  }
}

const DeeperComponent = memo((props: DeeperProps) => {
  useEffect(() => {
    console.log('DeeperComponent has been rendered!')
  })

  return <h1>{props.counter.counter}</h1>
})

export default function App() {
  const [, setCounter] = useState(0)

  function handleClick() {
    setCounter((prev) => prev + 1)
  }
  return (
    <div className="App">
      <Component counter = {100} />
      <DeeperComponent counter = {{ counter: 100 }} />
      <button onClick = {handleClick}>+</button>
    </div>
    )
}
```
- 위 예시에서 보면 Component 컴포넌트의 경우 동일 props가 전달되었을 때 얕은 비교로 메모이제이션이 동작한다.
- 그러나 DeeperComponent 컴포넌트의 경우, 객체의 첫 번째 깊이를 넘어가기 때문에 얕은 비교가 불가능해져서 메모이제이션이 동작하지 않는다.
- 이런 예시를 보게 되면, 프로젝트를 진행할 때 내가 원하는 메모이제이션이 제대로 일어나지 않을 수 있다는 점을 유의해야 할 것 같다.

### 정리
- 자바스크립트에서 객체 비교의 불완전성은 반드시 기억해 두어야 한다.
- 리액트에서도 이 한계를 뛰어넘을 수 없기 때문에 얕은 비교만을 사용해 비교를 수행해 필요한 기능을 구현하고 있다.

<br/>

## 1.2 함수
### 함수란 무엇인가?
- 리액트에서 컴포넌트를 만드는 함수는
```tsx
function Component(props) {
  return <div>{props.hello}</div>
}
```
- Component라고 하는 함수를 선언하고 매개변수로 props라고 부르는 단일 객체 타입을 받으며 return 문으로 JSX를 반환한다.

### 함수를 정의하는 4가지 방법
- 함수 선언문
  ```tsx
  function add(a, b){
    return a + b
  }
  ```
  - 함수 선언문은 말 그대로 '선언'이고 어떠한 값도 표현하지 않는다.
 
- 함수 표현식
  - 함수 표현식에 대해 알아보기 전에 '일급 객체'라는 개념을 알고 있어야 한다.
  - 일급 객체란, 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
  - 자바스크립트에서 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 할당도 가능하다.
  ```tsx
  const sum = function (a, b) {
    return a + b;
  }

  sum(10, 24) // 34
  ```
  - 함수 표현식과 함수 선언 식의 가장 큰 차이는 호이스팅(hoisting) 여부다.
  - 호이스팅이란, 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징이다.
  ```tsx
  hello() // hello

  function hello() {
    console.log('hello')
  }

  hello() // hello
  ```
  - 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다.
  - 이러한 함수의 호이스팅 특징 덕분에 함수 선언문이 미리 메모리에 등록됐고, 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 되는 것이다.
  - 반면, 함수 표현식도 호이스팅이 발생하지만 조금 다르게 동작한다.
  - 함수의 호이스팅과는 다르게, 호이스팅되는 시점에서 var의 경우에는 undefined로 초기화한다는 차이가 있다.
  - 그런데 요즘 var를 잘 안 쓰니까 let과 const의 관점에서 봐야하고 이 둘은 var과는 또 다른 특징이 있다.
  - let과 const도 호이스팅은 가능하지만 초기화를 하지 않는 특징이 있어서 선언 전에 미리 사용하려면 ReferenceError를 일으킨다.
  ```tsx
  console.log(myVar); // undefined
  var myVar = "Hello";
  console.log(myVar); // Hello
  
  console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
  let myLet = "Hello";
  console.log(myLet); // Hello
  ```
  - 본인은 개인적으로 호이스팅 되는걸 좋아하진 않아서 프로젝트를 진행할 때 함수 표현식을 사용하고 있다.
 
- Function 생성자
  - 이 방법은 사용하지 말자.
 
- 화살표 함수
  - ES6에서 새롭게 추가된 함수 생성 방식이다. 본인도 자주 사용하는 문법인데, 앞서 언급한 함수 생성 방식과 몇 가지 큰 차이점이 있다고 한다.
  - 화살표 함수에는 arguments가 존재하지 않는다. arguments는 함수에 전달된 인자들의 배열과 유사한 객체이다.
  ```tsx
  function showArguments() {
    console.log('Number of arguments:', arguments.length);
    for(let i = 0; i < arguments.length; i++) {
      console.log('Argument ' + i + ':', arguments[i]);
    }
  }

  showArguments(10, 'Hello', true);
  // 출력:
  // Number of arguments: 3
  // Argument 0: 10
  // Argument 1: Hello
  // Argument 2: true
  ```
  - 그리고 화살표 함수와 일반 함수의 가장 큰 차이점은 바로 this 바인딩이다.
  - this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.
  - 만약 함수가 일반 함수로서 호출된다면, 그 내부의 this는 전역 객체를 가리키게 된다.
  - 그러나 화살표 함수는 함수 자체의 바인딩을 갖지 않아서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다.
  ```tsx
  class Component extends React.Component {
    constructor(props) {
      super(props)
      this.state = {
        counter: 1,
      }
    }

    functionCountUp() {
      console.log(this) // undefined
      this.setState((prev) => ({ counter: prev.counter + 1 })
    }

    ArrowFunctionCountUp = () => {
      console.log(this) // class component
      this.setState((prev) => ({ counter: prev.counter + 1 })
    }

    render() {
      return (
        <div>
          {/* Cannot read properties of undefined (reading 'setState') */}
          <button onClick={this.functionCountUp}>일반 함수</button>
          {/* 정상적으로 작동한다. */}
          <button onClick={this.ArrowFunctionCountUp}>화살표 함수</button>
        </div>
      )
    }
  }
  ```

### 다양한 함수 살펴보기
- 즉시 실행 함수
  - 보통 IIFE(Immediately Invoked Function Expression)이라고 부른다.
  - 말 그대로 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다.
  - 단 한 번만 호출되고, 다시금 호출할 수 없는 함수다.
  ```tsx
  (function (a, b) {
    return a + b
  })(10, 24); // 34

  ((a, b) => {
      return a + b
    },
  )(10, 24) // 34
  ```

- 고차 함수
  - 앞서 언급했듯, 자바스크립트의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다.
  ```tsx
  const doubledArray = [1, 2, 3].map((item) => item * 2)

  doubledArray // [2, 4, 6]
  ```
  ```tsx
  const add = function (a) {
    return function (b) {
      return a + b
    }
  }

  add(1)(3) // 4
  ```

### 함수를 만들 때 주의해야 할 사항
- 함수의 부수 효과를 최대한 억제하라
  - 함수의 부수 효과(side-effect)는 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다.
  - 이러한 부수 효과가 없는 함수를 순수 함수라 부른다.
  - 리액트 관점에서 본다면 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화 하는 것이 중요하다고 볼 수 있다.
  - useEffect의 사용은 피할 수 없지만 최소한으로 줄임으로써 함수의 역할을 좁히고, 버그를 줄이며, 컴포넌트의 안정성을 높일 수 있다.
- 가능한 한 함수를 작게 만들어라
  - 함수당 코드의 길이가 길어질 수록 문제를 일으킬 여지가 있는 코드가 있을 확률이 커지고, 내부에서 무슨 일이 일어나는지 추적하기 어려워진다.
- 누구나 이해할 수 있는 이름을 붙여라
  - 가능한 한 함수 이름은 간결하고 이해하기 쉽게 붙이는 것이 좋다.

<br/>

## 1.3 클래스
### 클래스란 무엇인가?
- constructor
  - constructor는 생성자로, 객체를 생성하는 데 사용하는 특수한 메서드다.
  - 단 하나만 존재할 수 있으며, 여러 개를 사용한다면 에러가 발생한다.
  - 그러나 생성자에서 별다르게 수행할 작업이 없다면 생략하는 것도 가능하다.
  ```tsx
  // 오류
  class Car {
    constructor (name) {
      this.name = name
    }

    // SyntaxError: A class may only have one constructor
    constructor (name) {
      this.name = name
    }
  ```
  ```tsx
  // 정상
  class Car {
    // constructor 없어도 됨.
  }
  ```
- 프로퍼티
  - 프로퍼티란 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값을 의미한다.
  ```tsx
  class Car {
    constructor(name) {
      // 값을 받으면 내부에 프로퍼티로 할당된다.
      this.name = name
    }
  }

  const myCar = new Car('자동차') // 프로퍼티 값을 넘겨주었다.
  ```
- getter와 setter
  - getter란 클래스에서 무언가 값을 가져올 때 사용된다.
  - getter를 사용하기 위해서는 get을 앞에 붙여야 하고, 뒤이어서 getter의 이름을 선언해야 한다.
  ```tsx
  class Car {
    constructor(name) {
      this.name = name
    }

    get firstCharacter() {
      return this.name[0]
    }
  }

  const myCar = new Car('자동차')

  myCar.firstCharacter // 자
  ```
  - 반대로 setter란 클래스 필드에 값을 할당할 때 사용한다. 마찬가지로 set이라는 키워드를 먼저 선언하고, 그 뒤를 이어서 이름을 붙이면 된다.
  ```tsx
  class Car {
    constructor(name) {
      this.name = name
    }

    get firstCharacter() {
      return this.name[0]
    }

    set firstCharacter(char) {
      this.name = [char, ...this.name.slice(1)].join('')
    }
  }

  const myCar = new Car('자동차')

  myCar.firstCharacter // 자

  // '차'를 할당한다.
  myCar.firstCharacter = '차'

  console.log(myCar.firstCharacter, myCar.name) // 차, 차동차
  ```
- 인스턴스 메서드
  

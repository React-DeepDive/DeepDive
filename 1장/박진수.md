# [1장] 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등 비교
### 자바스크립트의 데이터 타입
원시 타입
- undefined
  - 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값이다.
  ```tsx
  let foo;

  typeof foo === 'undefined' // true

  function bar(hello) {
    return hello;
  }

  typeof bar() === 'undefined'; // true
  ```
  - null과 undefined 원시 타입은 각각 null과 undefined만 가질 수 있으며, 그 밖의 타입은 가질 수 있는 값이 두개 이상(boolean의 true, false와 같이) 존재한다.
 
- null
  - 아직 없거나 비어있는 값을 표현할 때 사용한다.
  ```tsx
  typeof null === 'object' // true
  ```
  - 그런데 문제는 null 타입이 'object' 결과를 도출하고 이는 JS의 초창기 문제다.
  - 그래서 옵셔널 체이닝을 활용해서 undefined로 분기처리 하는 것이 TypeError를 방지할 수 있는 방법이라고 생각한다.
 
- Boolean
  - true와 false만을 가질 수 있는 데이터 타입이다. 주로 조건문에 많이 쓰인다.
  - 다만 조건문에서 boolean 형 이외에도 마치 true와 false로 취급되는 truthy와 falsy가 있다는 걸 기억해야 한다.
  - falsy
  ```md
  - false: 대표적인 falsy 값
  - 0, -0, 0n, 0x0n: falsy
  - NaN: falsy
  - undefiend: falsy
  ```
  - truthy
  ```md
  - 객체와 배열은 내부에 값이 존재하는지 여부와 상관없이 truthy로 취급된다.
  - 즉, {}, [] 모두 truthy한 값이다.
  - 특히 개발할 때 분기처리를 단순히 진행한다면 truthy의 이러한 속성 때문에 배열에 값이 없어도 통과되므로 주의해야한다.
  
  ```tsx
  const useCafeStudyFilterStore = create<CafeStudyType>((set) => ({
  categories: [],
  dates: [],
  cafes: [],
  toggleCategory: (category) =>
    set((state) => ({
      categories: state.categories.includes(category)
        ? state.categories.filter((c) => c !== category)
        : [...state.categories, category],
    })),
  toggleDate: (date) =>
    set((state) => ({
      dates: state.dates.includes(date)
        ? state.dates.filter((d) => d !== date)
        : [...state.dates, date],
    })),
  toggleCafe: (cafe) =>
    set((state) => ({
      cafes: state.cafes.includes(cafe)
        ? state.cafes.filter((c) => c !== cafe)
        : [...state.cafes, cafe],
    })),
  }));

  const { categories, dates, cafes, toggleCategory, toggleDate, toggleCafe } = useCafeStudyFilterStore();

  {categories || dates || cafes ? (
    <Style.FilterBar>|</Style.FilterBar>
  ) : null} // 여기서 categories, dates, cafes 데이터가 없어도 truthy로 판단되어서 '|'가 렌더링 되는 문제.
  ```
  
- Number
  - Number는 -(2^53 - 1)과 2^53 - 1 사이의 값을 저장할 수 있다.
  - 그 이외의 값은 BigInt가 처리할 수 있다.
  ```tsx
  const a = 1;

  const maxInteger = Math.pow(2, 53);
  maxInteger - 1 === Number.MAX_SAFE_INTEGER // true

  const minInteger = -(Math.pow(2, 53) - 1)
  minInteger === Number.MIN_SAFE_INTEGER // true
  ```
  - 또한 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않아서 각 진수별로 값을 표현해도 모두 10진수로 해석된다.
 
- BigInt
  - ES2020에서 새롭게 나온 것으로, 앞서 말한 Number가 커버하지 못하는 범위까지 다룰 수 있다.
 
- String
  - 자바스크립트 문자열의 특징 중 하나는 문자열이 원시 타입이며 변경 불가능하다는 것이다.
  - 한번 문자열이 생성되면 그 문자열을 변경할 수 없다.
  ```tsx
  const foo = 'bar';

  console.log(foo[0]); // 'b'

  foo[0] = 'a';

  console.log(foo); // bar -> 반영 안됨.
  ```

- Symbol
  - ES6에서 새롭게 추가된 7번째 타입으로, 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌다.
  - 심벌은 오직 Symbol() 함수를 사용해서만 만들 수 있다.
  ```tsx
  const key = Symbol('key');
  const key2 = Symbol('key');

  key === key2; // false

  // 동일한 값을 사용하기 위해서는 Symbol.for를 활용한다.
  Symbol.for('hello') === Symbol.for('hello'); // true
  ```

객체 타입
- 원시 타입을 제외한, 자바스크립트를 이루고 있는 대부분의 타입이 객체 타입이다.
- 여기에는 배열, 함수, 정규식, 클래스 등이 포함된다.
- 객체 타입은 참조를 전달한다고 해서 참조 타입으로도 불린다는 점을 기억해야 한다.
```tsx
const hello1 = function () {};
const hello2 = function () {};

hello1 === hello2; // false
// 함수의 내용이 같아 보여도 참조가 다르기 때문에 false가 반환된다.
```

### 값을 저장하는 방식의 차이

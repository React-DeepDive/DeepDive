# 01장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트

- Boolean
  - 조건문 내에서 false로 취급되는 값 `falsy`, falsy로 취급되는 값 이외는 `truthy` 값으로 취급된다.
  - `false`, `0`, `’’(빈 문자열)`, `null`, `undefined`, `NaN`는 모두 falsy 값이다.
  - `{}`,`[]` 는 falsy 값의 목록에 포함되지 않기 때문에 truthy 값으로 취급된다.
- null
  - 명시적으로 비어 있음을 나타내는 값.
  - `typeof null`은 ‘object’를 반환한다.
- undefined
  - 선언 후 값을 할당하지 않은 변수.
- Number
  - 각 진수별로 값을 표현해도 모두 10진수로 해석되어 동일한 값으로 표시된다.
  - 실제 사용 가능한 숫자의 범위는 `Number.MIN_SAFE_INTEGERD`와 `Number.MAX_SAFE_INTEGER`로 정의되어 있다.
- BigInt
  - Number 타입으로는 안전한게 표현할 수 없는 매우 큰 정수 값을 다룰 때 사용.
  - 정수 리터럴 뒤에 `n`을 붙여서 생성할 수 있다.
- String
  - 텍스트 타입 데이터.
  - 템플릿 리터럴(````)을 사용하면 줄바꿈이 가능하고 문자열 내부에 표현식을 사용할 수 있다.
- Symbol
  - 중복되지 않는 고유한 값을 나타내기 위해 사용.
  - 심벌 함수 `Symbol()`을 사용해서만 만들 수 있다.

### 객체 타입

객체 타입은 원시 타입 이외의 모든것, `배열` `함수` `정규식` `클래스` 등이 포함된다.

참조를 전달한다고 해서 참조 타입(reference type)으로도 불린다.

원시 타입은 불변 형태의 값으로 저장되지만 객체 타입은 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

```jsx
let hello = '123';
let hi = hello;

console.log(hello === hi); // true

let obj1 = { name: 'mimi' };
let obj2 = { name: 'mimi' };

// 객체의 참조가 다르기 때문에 내부의 값이 같음에도 다르다고 평가된다.
console.log(obj1 === obj2); // false
console.log(obj1.name === obj2.name); // true
```

<br/>

---

### Object.is

[Object.is](http://Object.is) 메서드는 두 값을 비교할 때 사용된다. 엄격한 동등 비교(`===`)와 유사한 기능을 하지만 몇 가지 차이가 있다. 하지만 객체 비교에는 별 차이가 없다.

```jsx
Object.is(NaN, NaN); // true
NaN === NaN; // false

Object.is(+0, -0); // false
+0 === -0; // true

Object.is(NaN, 0 / 0); // true
NaN === 0 / 0; // false

Object.is({}, {}); // false;
```

<br/>

### 리액트에서의 동등 비교

리액트에서는 상태나 속성의 변경을 감지하고 리렌더링을 결정할 때 주로 얕은 비교를 수행한다.

React에서는 이러한 비교를 위해 `Object.is`를 기반으로 하는 `shallowEqual`이라는 함수를 통해 얕은 비교를 수행한다.

> **얕은 비교를 수행하는 이유**

1. 깊은 비교에 비해 계산 비용이 훨씬 낮다.
2. 대부분은 최상위 수준의 프로퍼티에 상태 변경이 발생한다.
3. React는 불변성을 권장하기에 얕은 비교를 통해 객체가 변경되었는지 쉽게 판단한다.
4. 개발자가 선택적으로 깊은 비교를 수행할 수 있게 한다.

<br/>

---

### 일급 객체

자바스크립트에서 함수는 일급 객체다. 함수는 다른 함수의 매개 변수 또는 값으로 사용될 수 있다.

### 함수 표현식과 선언 식의 차이

가장 큰 차이는 호이스팅 여부다. 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다. 이를 통해 코드의 순서와 상관 없이 정상적으로 함수를 호출할 수 있게 한다.

```jsx
console.log(hello()); // 안녕

function hello() {
   return '안녕';
}
```

반면에 함수 표현식은 함수를 변수에 할당한다. 함수가 값으로써 변수에 할당될 때에는 함수 호이스팅과는 다르게 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다.

```jsx
console.log(hello()); // hello is not a function

var hello2 = () => '안녕';
```

<br/>

### 화살표 함수

화살표 함수는 일반 함수 생성 방식과 차이가 있다.

1. 생성자 함수로 화살표 함수를 사용할 수 없다.

   ```jsx
   const Car = (name) => {
      this.name = name;
   };

   const car1 = new Car('자동차'); // Car is not a constructor
   ```

2. arguments가 존재하지 않는다.

   ```jsx
   const hello = () => console.log(arguments);

   hello(); // arguments is not defined

   /* rest parameter */
   const hello = (...rest) => console.log(rest);

   hello(1, 2, 3); // [1,2,3]
   ```

3. this 바인딩이 다르다.

   ```jsx
   화살표 함수는 자신을 포함하고 있는 외부 스코프(lexical scope)의 this를 상속 받는다.
   즉, 화살표 함수는 실행될 때의 this 값을 바인딩하지 않고, 함수가 선언된 시점의 this 값을 유지한다.
   ```

### 즉시 실행 함수

함수를정의하고 즉시 실행되는 함수를 말한다. 독립적인 함수 스코프를 운용할 수 있어 내부에 있는 값은 외부에서 접근이 불가능하다.

```jsx
const UserList = (() => {
   const users = [];

   return {
      getUser: () => users,

      addUser: (user) => {
         users.push(user);
         return users;
      },

      removeUser: () => {
         users.pop();
         return users;
      },
   };
})();

UserList.getUser(); // []
UserList.addUser('철수'); // ['철수']
UserList.removeUser; // []

console.log(users); // Uncaught ReferenceError: users is not defined
```

### 고차 함수

고차함수는 함수가 `일급 객체`라는 특성을 활용하여 함수를 인수로 받거나 반환하는 함수다.

```jsx
const getBoundingBox = (startCoordinate) => {
   return (endCoordinate) => {
      const [startX,startY] = startCoordinate;
      const [endX,endY] = endCoordinate;

      return {
         x: startX,
         y: startY,
         w: Math.abs(endX - startX);
         h: Math.abs(enxY - startY)
      }
   }
}

// { x:10, y:10, w:10, h:10 }
const boundingBox = getBoundingBox([10,10])([20,20]);

```

---

### 클래스

자바스크립트에서 클래스는 객체를 생성하기 위한 템플릿이다. 기존의 프로토타입 기반의 상속을 좀 더 쉽고 명확하게 사용할 수 있게 한다. 클래스는 `데이터`와 데이터를 조작하는 `메서드`로 구성된다.

> **constructor**

- constructor는 생상자로, 객체를 생성하는데 사용되는 특수한 메서드다.
- 단 하나만 작성할 수 있으며 여러 개를 사용한다면 에러가 발생한다.
- 생략 가능하다.

<br/>

> 프로퍼티

- 프로퍼티는 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성 값을 의미한다.

<br/>

> **getter / settter**

- getter는 클래스 내부 값을 가져올 때 사용된다. `get` 키워드를 사용한다.
- setter는 클래스 내부 값을 할당할 때 사용된다. `set` 키워드를 사용한다.

<br/>

> **인스턴스 메서드**

- 클래스 내부에서 선언한 메서드를 말한다.
- 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불리기도 한다.

<br/>

> 정적 메서드

- 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드다.
- 정적 메서드 내부에서의 this는 클래스 자신을 가리킨다.
- `static` 키워드를 사용한다.

<br/>

> 프로토타입 체인

프로토타입 체인은 객체가 자신의 프로퍼티나 메서드를 가지고 있지 않을 경우, 해당 객체의 프로토타입(부모 객체)로부터 프로퍼티나 메서드를 상속받는 메커니즘을 말한다. 이러한 방식으로 자바스크립트에서는 객체 간의 `상속`을 구현한다.

```jsx
function Person(name) {
   this.name = name;
}

Person.prototype.getName = function () {
   console.log(`${this.name}`);
};

// person1은 getName 메서드를 직접 가지고 있지 않지만 Pserson.prototype에서 이를 상속 받았다.
// 이것이 프로토타입 체인의 기본적인 작동 방식이다.
const person1 = new Person('철수');

person1.getName(); // '철수'
```

<br/>

---

### 클로저

자바스크립트에서 클로저는 함수와 그 함수가 선언된 `렉시컬 환경`과의 조합을 의미한다. 클로저는 내부 함수가 외부 함수의 스코프에 있는 변수에 접근할 수 있게 해주며, 외부 함수의 실행이 끝난 후에도 외부 함수의 변수에 접근할 수 있게 한다. 이는 데이터 캡슐화와 정보 은닉을 구현할 때 유용하게 사용된다.

```jsx
function outerFunction() {
   const a = 12;

   function innerFunction() {
      // 내부 함수에서 외부 함수 스코프에 있는 변수에 접근 가능하다.
      console.log(a); // 12
   }

   return innerFunction;
}
```

<br/>

> **클로저의 장점**

- `데이터의 캡슐화와 정보 은닉`
  - 특정 함수에 대한 접근 권한을 제한할 수 있으며, 전역 변수의 사용을 줄여 충돌을 방지할 수 있다.
- `상태 유지`
  - 외부 함수의 상태를 내부 함수가 호출될 때마다 유지할 수 있게 해준다.

<br/>

> **클로저의 단점**

- `메모리 사용`
  - 클로저는 선언될 때마다 그 선언적 환경을 기억해야하므로 이 변수들은 가비지 컬렉션의 대상이 되지 않아 메모리 사용이 증가할 수 있다.

<br/>

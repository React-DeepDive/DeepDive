# 2장

## 2.1 JSX

### JSX란?

페이스북이 만든 XML과 유사한 내장구문으로 리엑트에 종속적이지 않은 독자적인 문법

- 자바스크립트 표준 아님, 그래서 트랜스파일 없으면 에러 남
- 자바스크립트 내부에서 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있도록 함
- HTML 문법이랑 자바스크립트 문법이 뒤섞여서 가독성을 해친다는 의견도 있긴함

### 구성

<aside>
💡

기본적으로 사용되지 않는 요소들은 제외하였음

</aside>

- JSXElement
  - 가장 기본 요소로 HTML(element)의 요소와 비슷한 역할을 함
  - html 태그랑 구분해야 하므로 반드시 네이밍은 대문자로 시작해야 함
  - 요소 이름으로 `$` 와 `_` 외의 다른 특수문자나 숫자로 시작못함
  - 종류
    - `<>`
    - `</>`
    - `< />`
    - `<></>`
- JSXAttribute
  - `JSXElement`에 부여할 수 있는 속성으로 필수값이 아님
  - 키와 값으로 짝을 이루어서 표현한다.
  - 값으로 문자열이나 표현식이 들어가야함
    ```jsx
    <Child attribute = "gg" />
    <Child attribute = <div>hello</div> />
    ```
- JSXChildren
  - JSXElement의 자식 값
  - 값으로 다른 JSX요소나 빈 값이 들어온다.
    ```jsx
    <Child>gg</Child>
    <Child><div>gg</div></Child>
    <Child>{()=>console.log('gg')}</Child>
    ```
- JSXStrings
  - 문자열에서 JSX를 다루거나 JSX내에서 문자열을 출력하는 경우
  - HTML과 JSX 사이의 복붙을 용이하게 하기 위해 HTML처럼 `\` 을 이스케이프 문자열로 처리하고 있지 않음
    ```jsx
    <button>\</button> // good
    let escaple1 ="\" // x
    ```

### JSX는 어떻게 JS에서 변환될까?

`@babel/plugin-transform-react-jsx` 플러그인이 트랜스파일러 역할을 해 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환한다.

때로는 직접 `createElement` 를 사용해 컴포넌트를 구성하는 편이 나을 수 도 있다.

```jsx
// 변환 전
const ComponentA = <A required={true}>Hello World</A>
const ComponentB = <>Hello Wolrd</>

const ComponentC = (
	<div>
		<span>hello world</span>
	</div>
)
```

```jsx
// 변환 후

var Component A = React.createElment(
	A,
	{
		required: true,
	},
	"Hello World",
)
var ComponentB = React.createElement(React.Fragment, null, 'Hello World')
var ComponentC = React.createElement(
	'div',
	null,
	React.createElement('span', null, 'hello wolrd'),
)
```

리액트 17, 바벨 7.9.0 이후 버전에서 추가된 자동 런타임으로 트랜스파일한 결과는 위보다 조금 더 가독성이 좋다.

이렇게 JSX에 대해서 알아봤는데 내부에서 JSX가 어떻게 변환되는지, 어떤 결과물을 만들어내는지 알아두면 리액트에 App을 만들때 도움이 되고, JSX 기반의 또 다른 애플리케이션을 만들때 도움이 될 것이다.

<aside>
💡

createElement를 사용할 일이 있을까..? 바닐라 자바스크립트로 SPA를 만들거나 레거시 코드를 읽을때, 라이브러리 코드를 까볼때 도움이 될 수도..?

</aside>

## 가상 DOM과 리액트 파이버

리액트의 가장 큰 특징인 **가상 DOM**에 대해 알아보자.

### DOM과 브라우저 렌더링 과정

- DOM
  - 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있는 객체
- 브라우저 렌더링 과정

  - HTML 파일 다운로드
  - 브라우저의 렌더링 엔진이 HTML 파싱 → DOM 노드로 구성된 DOM 트리 구축
  - CSS 파일 만나면 CSS 파일 다운로드
  - CSS 노드로 구성된 CSSOM 트리 구축
  - DOM 노드를 순회하면서 사용자 눈에 보이는 노드만 방문(최적화를 위해)
  - 눈에 보이는 노드에 대해서 CSSOM 정보를 찾고 이 노드에 적용한다. 과정은 두 가지다.

    - 레이아웃
      - 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산
    - 페인팅
      - 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정
      <aside>
      💡

    파싱은 위에서 부터 아래로 하는데 CSS 다운로드는 비동기 적으로 별개로 하는건가?

    → 그렇다. 다만, 렌더링은 CSS 파일이 완전히 로드되고 파싱된 후에야 진행된다.

    그렇지 않으면 CSS 파일이 거대해서 다운이 끝나지도 않았는데 스타일이 안입혀진채로 렌더링이 될 수 있기 때문이다. 어쩌면 당연한것..

    참고로 태그의 인라인 스타일 또한 CSSOM 정보를 찾고 노드에 적용할때 같이 반영된다.

    </aside>

    ### 가상 DOM의 탄생 배경

    요즘처럼 SPA앱의 경우 사용자와의 인터랙션이 빈번하므로 복잡하고 비용이 많이 드는 렌더링 과정을 잘 관리해야 한다.

    예를 들어, 페이지가 변경되는 경우 새로 HTML 파일을 받아서 렌더링을 하면 비용이 너무 크다.

    사용자 입장에서 깜빡이지 않고 페이지를 이동할 수 있지만 매번 요소의 위치를 재계산하고(레이아웃), 스타일을 입히는(페인팅) 과정은 개발자 입장에서 DOM을 관리하기가 부담스럽게 만든다.

    수많은 DOM의 노드들을 직접 관리하기가 너무 힘들다는 것이다. 우리는 모든 DOM의 변경보다 DOM 결과물 하나만 알고 있으면 된다. 이것을 **가상 DOM**이 해결해준다.

    가상 DOM을 사용하면 DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 되므로 여러번 렌더링이 발생했을때 렌더링 과정을 최소화 할 수 있다.

    <aside>
    💡

    가상 DOM에 대해서 DOM을 관리하는 브라우저보다 빠르다는 오해가 있지만 실제로는 무조건 빠른 것이 아니라 대부분의 상황에서 웬만한 앱을 만들 수 있을 정도로 충분히 빠르다는 것이다.

    </aside>

    ### 리액트 파이버

    가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 자바스크립트 객체로 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, 둘 사이에 차이가 있으면 파이버를 기준으로 렌더링을 요청한다.

    그리고 이 모든 작업은 **비동기**로 일어난다.

    <aside>
    💡

    파이버의 원리에 대해서는 복잡하기도 하고 딱히 알 필요가 없다고 판단되어 생략
    다만, 알아야 할 것은 파이버의 가상 DOM은 자바스크립트 객체로 관리되고, 값을 가지고 있는 UI를 관리하는 라이브러리 라는 것이다.

    즉, UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것이다.

    </aside>

    ### 파이버 트리

    현재 모습을 담은 파이버 트리와 작업 중인 상태를 나타내는 `workInProgress` 트리다.

    평소에는 파이버 트리에 포인터가 위치해있지만, 파이버 작업이 끝나면 포인터를 변경해 현재 트리를 `workInProgress` 트리로 바꾸는 **더블 버퍼링**을 시행한다.

    **더블 버퍼링**이란, 사용자에게 미처 다 그리지 못한 모습을 보여주지 않기 위해 내부적으로 보이지 않는 곳에서 그다음으로 그려야 할 그림을 미리 그린 다음, 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법을 말한다.

    즉, 과정은 다음과 같다.

    1. 현재 UI 렌더링을 위해 존재하는 트리인 curent를 기준으로 모든 작업이 시작
    2. 업데이트 발생 시 파이버는 리액트에서 새로 받은 데이터로 새로운 `workInProgress` 트리 빌드 시작
    3. 끝나면 다음 렌더링에 이 트리 사용
    4. UI에 최종적으로 렌더링되어 반영이 되면 `current`가 `workInProgress`로 변경됨

    ### 파이버 작업 순서

    1. 태그를 파싱해 트리로 도식화
    2. 업데이트가 되면 트리를 모두 새로 만드는게 아니라 기존 객체를 재활용해 내부 속성값만 초기화 하거나 바꾸는 형태로 트리 업데이트(파이버 단위로 나눠서 수행, 우선순위를 할당하는 것 또한 가능)

    ## 2.3 클래스 컴포넌트와 함수 컴포넌트

    ### 클래스 컴포넌트

    - 기본적으로 클래스 컴포넌트를 만들려면 클래스를 선언하고 `extends`로 만들고 싶은 컴포넌트를 `extends` 해야 한다. 다음 두개의 클래스를 사용하면 된다.
      - React.Component
      - React.PureComponent

    ```jsx
    class SampleComponent extends React.Component {
    	constructor(props) {
    		super(props)
    		this.state = {
    			count: 0,
    			isLimited: false,
    		}
    	}

    	handleClick = () => {
    		const newValue = this.state.count + 1
    		this.setState({count: newValue, isLimited: newValue >= 10})
    	}

    	render() {
    		const {
    			props: {required, text},
    			state: {count, isLimited},
    		} = this

    		return (
    			<h2>
    				<div>{required ? "필수" : "필수아님"}</div>
    				<div>{text}</div>
    				<div>{count}</div>
    				<button
    					onClick={this.handleClick}
    					disabled={isLimited}>
    					증가
    				</button>
    			</h2>
    		)
    	}
    }
    ```

    - constructor : 컴포넌트가 초기화되는 시점에 호출됨, `state`를 초기화하며 `super`를 통해 컴포넌트를 만들면서 상속받은 상위 컴포넌트, 즉 React.Component의 생성자 함수를 먼저 호출해 상위 컴포넌트에 접근 가능하게 하는 역할을 한다.
    - props: 컴포넌트에 특정 속성을 전달하는 용도
    - state: 컴포넌트 내부에서 관리하는 값으로 변화가 있을 때마다 렌더링 된다. **항상 객체여야 하는 것이 포인트**
    - 메서드 : 렌더링 함수 내부에서 사용되는 함수로 만드는 방법이 세가지 있음
      - 일반 함수:
        - this 바인딩 해야하므로 불편함
        - 화살표 함수:
          - 호출 시점이 아닌 작성 시점에 결정되는 정적 바인딩을 이용해 `this`가 저절로 상위 스코프로 결정되므로 편함
        - 렌더링 함수 내부에서 함수를 만들어 전달
          ```jsx
          <button onClick={() => this.handleClick()}증가</button>
          ```
          매번 렌더링시 새로운 함수를 새엉해서 할당하게 되므로 최적화가 안됨 → 지양
          **화살표 함수를 사용하자.**

    ### ~~생명주기 메서드~~

    ~~실행되는 시점은 크게 마운트, 업데이트, 언마운트이고, 이를 염두에 두고 각 메서드를 살펴보자.~~

    ~~굳이, 잘 안쓰이는 부분을 공부할 필요가 없다고 생각됨. 다만 ,대충 어떻게 생겼고, 왜 함수 컴포넌트가 더 우수한지 알고 넘어가자.~~

    ### 한계

    - 데이터 흐름 추적 어려움
      - 생명주기 메서드를 사용하다보면 `state`를 추적하기가 매우 어려움
      - 생명주기 메서드마다 실행되는 순서가 있지만 코드를 잘 짜지 않는 이상 이해하기 어려움
    - 내부 로직 재사용 어려움
      - 컴포넌트 마다 반복되는 로직을 render props나 HOC 패턴을 이용해야 하는데 앱 규모가 커ㅣㅈㄹ수록 `props` 가 많아지는 래퍼지옥에 빠질 위험성이 커진다.
    - 기능이 많아질수록 컴포넌트 크기가 커짐
    - 클래스는 함수에 비해 상대적으로 어려움
      - 프로토타입 기반의 언어에서 클래스는 비교적 뒤늦게 나온 개념인 데다가, 다른 언어의 클래스, this와는 좀 다른 개념이어서 사용하기가 쉽지 않다.

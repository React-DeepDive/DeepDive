## 02장 - 리액트 핵심 요소 살펴보기

### 2.1 JSX란?

JS의 표준이 아니기에 트랜스파일러를 거쳐야하고 리액트의 전유물도 아니다.

JSX는 HTML을 JS 내부에 표현하는 것이 유일한 목적이 아니다. 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다.

### 2.2 가상 DOM과 리액트 파이버

DOM과 브라우저 렌더링 과정 살펴보기

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 위 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드 후 파싱해 CSS노드로 구성된 트리(CSSOM)를 만든다.
4. 브라우저는 만든 DOM 노드를 순회한다. (사용자 눈에 보이는 노드만 ← 트리 분석 과정 빠르게)
5. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 CSS 스타일 정보를 노드에 적용한다. 이때 DOM에 CSS를 적용하는 과정은 크게 레이아웃과 페인팅으로 나눌 수 있다.
   - 레이아웃: 각 노드가 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정으로 이 과정을 거치면 반드시 페인팅 과정도 거친다.
   - 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

렌더링 이후에 사용자의 인터렉션으로 웹페이지가 변경되는 상황이 SPA에서 더욱 많아졌다. 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 수고스럽고 결과적으로 DOM의 결과물을 아는것이 중요하다. 이러한 문제점을 가상 DOM이 해결해준다. DOM 계산을 브라우저가 아닌 메모리에서 처리하고 실제 변경의 준비가 끝나면 리액트는 실제 브라우저의 DOM에 반영한다. 여러 번 발생했을 렌더링 과정을 최소화하기에 부담을 덜 수 있다.

### 2.23 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트의 핵심 원리 중 하나는 컴포넌트의 상태(state)나 속성(props)이 변경되면 리렌더링이 발생하고, 이때 새로운 가상 DOM 트리가 생성된다. 새로운 가상 DOM 트리와 이전 가상 DOM 트리를 비교하여 변경된 부분만을 실제 DOM에 반영하고 이를 통해 성능을 향상시키고 불필요한 렌더링을 방지한다.

리액트의 Fiber 아키텍처는 이러한 가상 DOM과 렌더링 과정 최적화를 가능하게 해준다. Fiber는 특히 비동기적으로 작업을 수행할 수 있는 기능을 제공하며, 복잡한 컴포넌트 트리에서도 빠르게 렌더링할 수 있도록 도와준다.

파이버 재조정자가 가상 돔과 실제 돔을 비교해서 변경 사항을 수집하고 변경 관련 정보를 가진 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

파이버는 리액트에서 관리하는 JS 객체이고 하나의 작업 단위로 구성 되어있다. 파이버는 리액트 요소와 달리 렌더링 시 새로 생성되지 않고 가급적 재사용된다. 리액트 컴포넌트의 정보를 1:1로 가진 것이 파이버라고 볼 수 있다. 파이버는 state변경, 메서드 실행, DOM 변경이 필요한 시점 등에 실행된다. 리액트는 값을 가진 UI(문자열, 객체, 배열 등)를 관리하는 라이브러리라고 할 수 있다.

리액트 내부의 파이버와 재조정자가 DOM을 변경하는 작업과 무엇이 변경되었는지 파악하고 관리하는 것을 내부 알고리즘을 통해 관리해 줌으로써 대규모 웹 애플리케이션을 효율적으로 유지보수하고 관리할 수 있게 된 것이다.

### 2.3 클래스형 컴포넌트와 함수형 컴포넌트

클래스형 컴포넌트의 생명주기 메서드

- 마운트: 컴포넌트가 생성되는 시점
- 업데이트: 이미 생성된 컴포넌트의 내용이 변경되는 시점
- 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점

`render()`

이 함수는 UI를 렌더링하기 위해서 쓰인다. 그리고 이 렌더링은 마운트와 업데이트 과정에서 일어난다. 주의할 점은 render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다. 따라서 state를 직접 업데이트하는 this.setState를 호출하면 안 된다. state를 변경하는 일은 클래스형 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야 한다.

왜 함수형 컴포넌트에 훅을 도입한 새로운 패러다임으로 넘어갔을까?

- 데이터의 흐름을 추적하기 어렵다. 여러 다른 메서드에서 state의 업데이트가 일어날 수 있으며, 메서드의 순서가 강제돼 있는 것이 아니기 때문에 가독성이 떨어진다. 생명주기 메서드의 순서와 상관없이 코드가 작성돼 있을 수 있다.
- 내부 로직의 재사용이 어렵다. 중복되는 로직을 재사용하고 싶다고 가정한다면 상속해서 중복 코드를 관리 할 수 있지만 상속되고 있는 클래스의 흐름을 쫓아야 하기 때문에 복잡도가 증가한다. 고차 컴포넌트로 감싸거나 props를 넘겨주는 방식도 있지만 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트 내지는 props가 많아지는 wrapper hell에 빠질 위험이 커진다.

### 2.3.2 함수형 컴포넌트

리액트 16.8 버전 이전에는 단순히 무상태 컴포넌트를 구현하기 위한 수단이었지만 함수형 컴포넌트에서 사용 가능한 훅이 등장하면서 입지가 바뀌었다.

클래스형과 비교하면 render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요가 없고 state는 객체가 아닌 각각의 원시값으로 관리되어 사용하기 더욱 편해졌다. 렌더링하는 코드인 return에서도 굳이 this를 사용하지 않아도 props와 state에 접근할 수 있게 됐다.

생명주기 메서드의 부재

함수형 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수이다. 반면 클래스형 컴포넌트는 render 메서드가 있는 React.Component를 상속받아 구현하는 자바스크립트 클래스이다. 즉, 생명주기 메서드는 React.Component에서 오는 것이기 때문에 함수형 컴포넌트에서는 생명주기 메서드를 사용할 수 없다.

함수형 컴포넌트는 useEffect 훅을 통해 생명주기 메서드를 비슷하게 구현할 수 있다. 그러나 useEffect는 생명주기를 위한 훅이 아니고 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.